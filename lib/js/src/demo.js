// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE
'use strict';

var $$String                = require("bs-platform/lib/js/string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function ofString(param) {
  switch (param) {
    case "ella" : 
        return /* Ella */2;
    case "nosotras" : 
        return /* Nosotras */3;
    case "tu" : 
        return /* Tu */1;
    case "vosotras" : 
        return /* Vosotras */4;
    case "yo" : 
        return /* Yo */0;
    default:
      return /* Ellas */5;
  }
}

var Subject = /* module */[/* ofString */ofString];

function ofString$1(param) {
  switch (param) {
    case "ar" : 
        return /* Ar */0;
    case "er" : 
        return /* Er */1;
    default:
      return /* Ir */2;
  }
}

var Ending = /* module */[/* ofString */ofString$1];

function genPresentEnding(ending, subject) {
  switch (subject) {
    case 0 : 
        return "o";
    case 1 : 
        if (ending !== 0) {
          return "es";
        } else {
          return "as";
        }
    case 2 : 
        if (ending !== 0) {
          return "e";
        } else {
          return "a";
        }
    case 3 : 
        switch (ending) {
          case 0 : 
              return "amos";
          case 1 : 
              return "emos";
          case 2 : 
              return "imos";
          
        }
        break;
    case 4 : 
        switch (ending) {
          case 0 : 
              return "áis";
          case 1 : 
              return "éis";
          case 2 : 
              return "ís";
          
        }
        break;
    case 5 : 
        return "an";
    
  }
}

function genFutureEnding(_, subject) {
  switch (subject) {
    case 0 : 
    case 1 : 
        return "é";
    case 2 : 
        return "";
    case 3 : 
        return "emos";
    case 4 : 
        return "á";
    case 5 : 
        return "án";
    
  }
}

function conjugate(word, info) {
  var start = word.length - 2 | 0;
  var endingType = ofString$1($$String.sub(word, start, 2));
  var stem = $$String.sub(word, 0, start);
  var subjectType = ofString(info.subject);
  var match = info.tense;
  switch (match) {
    case "future" : 
        return word + genFutureEnding(endingType, subjectType);
    case "present" : 
        return stem + genPresentEnding(endingType, subjectType);
    default:
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/home/royce/conjugator/src/demo.re",
              86,
              2
            ]
          ];
  }
}

exports.Subject          = Subject;
exports.Ending           = Ending;
exports.genPresentEnding = genPresentEnding;
exports.genFutureEnding  = genFutureEnding;
exports.conjugate        = conjugate;
/* No side effect */
